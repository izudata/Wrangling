---
title: "Data_Wrangling_EDx"
author: "Izu"
date: "2024-12-21"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## R Markdown
 
To use external files such as the ones in the dslabs database, one needs to download and install the dslabs package using the command: install.packages("dslabs")

After installing the package, you may assign it to an object, for example: path

path <- system.file("extdata", package = "dslabs")

To view the list of files in the dslabs use: list.files(path)
 
 
To make the code simpler, one can move this file to one's working directory either through the file system directly or using the "file.copy()" function

Using paste is not recommended

You copy the file into your working dir using: file.copy(fullpath, getwd())

To check if the file exists, use: file.exists(filename)

To check the first three lines in a file, use: read_lines("murders.csv", n_max = 3). Before using the read_lines() function, one needs to call the tidyverse library: library(tidyverse)

library(dslabs)
library(tidyverse)    # includes readr
library(readxl)

# inspect the first 3 lines
read_lines("murders.csv", n_max = 3)

# read file in CSV format
dat <- read_csv(filename)

#read using full path
dat <- read_csv(fullpath)
head(dat)

#Ex：
path <- system.file("extdata", package = "dslabs")
files <- list.files(path)
files

filename <- "murders.csv"
filename1 <- "life-expectancy-and-fertility-two-countries-example.csv"
filename2 <- "fertility-two-countries-example.csv"
dat=read.csv(file.path(path, filename))
dat1=read.csv(file.path(path, filename1))
dat2=read.csv(file.path(path, filename2))
 

Column Type Customization: If you need to specify or change column types explicitly (e.g., forcing a column to be a specific type), you can use the col_types argument in read_csv()

dat <- read_csv(filename, col_types = cols(
  state = col_character(),
  abb = col_character(),
  region = col_character(),
  population = col_integer(),
  total = col_integer()
  ))

Note filename has been assigned to murders.csv

OR

dat <- read_csv("murder.csv", col_types = cols(
  state = col_character(),
  abb = col_character(),
  region = col_character(),
  population = col_integer(),
  total = col_integer()
  ))


OR

dat <- read_csv(fullpath, col_types = cols(
  state = col_character(),
  abb = col_character(),
  region = col_character(),
  population = col_integer(),
  total = col_integer()
  ))


A tibble is a data frame that:

Has a more readable printing style (doesn’t print the entire data if it’s large).
Avoids some common pitfalls of data frames, such as row names.
Allows for column names to be non-standard (e.g., spaces in column names) and provides more consistency across tidyverse packages.Tibbles allow column names to contain spaces, special characters, and non-standard names without issues.

Tibbles only print the first 10 rows by default, and show a summary of the columns that have more than 20 characters or complex types. This helps when working with large datasets.
The column names are displayed without quotes, and their types are inferred.

Case-insensitive match: If you're unsure about the exact casing and want to perform a case-insensitive match, you can use str_to_lower() or str_to_upper() from the stringr package to make the comparison case-insensitive.

Here's how you can do it:

library(dplyr)
library(stringr)

filtered_data <- dat %>% 
  filter(region == "South") %>% 
  select(state, population)


R-base import functions (read.csv(), read.table(), read.delim()) generate data frames rather than tibbles.
# read.csv to import the data
dat2 <- read.csv(filename)
class(dat2$abb)
class(dat2$region)

#### Full Example of a Correct Setup

```markdown
# Load libraries
{r setup, include=FALSE}
library(dplyr)

# Load the dataset (assuming it exists in the path provided)
dat <- read.csv("E:\Data_Wrangling\Wrangling\murders.csv")  # Make sure to adjust the file path



# Create the `filtered_data` object

dat <- read.csv("E:/Data_Wrangling/Wrangling/murders.csv")
filtered_data <- dat %>% 
  filter(region == "South") %>% 
  select(state, population)


summary(filtered_data)


### Explanation:

- **`{r filtered_data}`**: This is the code chunk header. 
  - `r` tells R Markdown that this is an R code chunk.
  - `filtered_data` is the optional name of the chunk. This name can be used for referencing or organizing chunks, but it's not necessary for the code to run correctly. You can leave it as just `{r}` if you prefer.
  
- **`summary(filtered_data)`**: This is the R code that will be executed inside the code chunk.
### Additional Notes:

1. **Chunk Options**: You can add chunk options to control how the output is displayed. 
   
 {r filtered_data, echo=TRUE, message=FALSE, warning=FALSE}
   summary(filtered_data) 

### Example in R Markdown:
markdown
# My Analysis


When you knit the R Markdown file, it will execute the code inside the chunk and display the output directly in the document.






### R Markdown

This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see <http://rmarkdown.rstudio.com>.

When you click the **Knit** button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this:

```{r cars}
summary(cars)
```

## Including Plots

You can also embed plots, for example:

```{r pressure, echo=FALSE}
plot(pressure)
```

Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.

url2 <- "https://archive.ics.uci.edu/ml/machine-learning-databases/breast-cancer-wisconsin/wdbc.data"
dat3 <- read_csv(url2, col_names = FALSE)
head(dat3)
there is no header. The col_names=FALSE argument is necessary.

number of row and columns

url3 <- "https://archive.ics.uci.edu/ml/machine-learning-databases/breast-cancer-wisconsin/wdbc.data"
df3 <- read_csv(url, col_names = FALSE)
nrow(df3)
ncol(df3)


In the Tidy Data section, you will learn how to convert data from a raw to a tidy format.

This section is divided into three parts: Reshaping Data, Combining Tables, and Web Scraping. There are comprehension checks at the end of each part.

### After completing the Tidy Data section, you will be able to:

Reshape data using functions from the tidyr package, including gather(), spread(), separate() and unite().
Combine information from different tables using join functions from the dplyr package.
Combine information from different tables using binding functions from the dplyr package.
Use set operators to combine data frames.
Gather data from a website through web scraping and use of CSS selectors.


# data "gapmider'" from dslabs:

library(tidyverse)
library(dslabs)
data("gapminder")

the data "gapminder" should not be confused with the library(gapminder)

# create and inspect a tidy data frame
tidy_data <- gapminder %>% 
  filter(country %in% c("South Korea", "Germany")) %>%
  select(country, year, fertility)
head(tidy_data)

# plotting tidy data:
tidy_data %>% 
  ggplot(aes(year, fertility, color = country)) +
  geom_point()
  
aes stands for aesthetic mapping. Aesthetic mappings describe how variables in the data are mapped to visual properties (aesthetics) of geoms. Aesthetic mappings can be set in ggplot() and in individual layers

# import and inspect example of original Gapminder data in wide format
path <- system.file("extdata", package="dslabs")
filename <- file.path(path,  "fertility-two-countries-example.csv")
wide_data <- read_csv(filename)
select(wide_data, country, `1960`:`1967`)

